diff --git a/pulp/floonoc/floonoc.cpp b/pulp/floonoc/floonoc.cpp
index 668a863..0d77e2d 100644
--- a/pulp/floonoc/floonoc.cpp
+++ b/pulp/floonoc/floonoc.cpp
@@ -36,6 +36,7 @@ FlooNoc::FlooNoc(vp::ComponentConf &config)
     this->dim_x = get_js_config()->get_int("dim_x");
     this->dim_y = get_js_config()->get_int("dim_y");
     this->router_input_queue_size = get_js_config()->get_int("router_input_queue_size");
+    this->atomics = get_js_config()->get_int("atomics");
 
     // Reserve the array for the target. We may have one target at each node.
     this->targets.resize(this->dim_x * this->dim_y);
diff --git a/pulp/floonoc/floonoc.hpp b/pulp/floonoc/floonoc.hpp
index 644696a..0a087a5 100644
--- a/pulp/floonoc/floonoc.hpp
+++ b/pulp/floonoc/floonoc.hpp
@@ -108,6 +108,9 @@ public:
     // this width so that the bandwidth corresponds to the width.
     uint64_t width;
 
+    // Whether Support Atomics
+    bool atomics; 
+
 private:
     // Callback called when a target request is asynchronously granted after a denied error was
     // reported
diff --git a/pulp/floonoc/floonoc.py b/pulp/floonoc/floonoc.py
index 2aa365c..bb3e393 100644
--- a/pulp/floonoc/floonoc.py
+++ b/pulp/floonoc/floonoc.py
@@ -47,7 +47,7 @@ class FlooNoc2dMesh(gvsoc.systree.Component):
         before the source output queue is stalled.
     """
     def __init__(self, parent: gvsoc.systree.Component, name, width: int,
-            dim_x: int, dim_y:int, ni_outstanding_reqs: int=8, router_input_queue_size: int=2):
+            dim_x: int, dim_y:int, ni_outstanding_reqs: int=8, router_input_queue_size: int=2, atomics: int=0):
         super(FlooNoc2dMesh, self).__init__(parent, name)
 
         self.add_sources([
@@ -64,6 +64,7 @@ class FlooNoc2dMesh(gvsoc.systree.Component):
         self.add_property('dim_x', dim_x)
         self.add_property('dim_y', dim_y)
         self.add_property('router_input_queue_size', router_input_queue_size)
+        self.add_property('atomics', atomics)
 
     def __add_mapping(self, name: str, base: int, size: int, x: int, y: int):
         self.get_property('mappings')[name] =  {'base': base, 'size': size, 'x': x, 'y': y}
diff --git a/pulp/floonoc/floonoc_network_interface.cpp b/pulp/floonoc/floonoc_network_interface.cpp
index 4124c25..f0621e1 100644
--- a/pulp/floonoc/floonoc_network_interface.cpp
+++ b/pulp/floonoc/floonoc_network_interface.cpp
@@ -130,6 +130,11 @@ void NetworkInterface::fsm_handler(vp::Block *__this, vp::ClockEvent *event)
         req->set_size(size);
         req->set_data(_this->pending_burst_data);
         req->set_is_write(burst->get_is_write());
+        if (_this->noc->atomics)
+        {
+            req->set_opcode(burst->get_opcode());
+            req->set_second_data(burst->get_second_data());
+        }
 
         // Get the target entry corresponding to the current base
         Entry *entry = _this->noc->get_entry(base, size);
@@ -174,8 +179,8 @@ void NetworkInterface::fsm_handler(vp::Block *__this, vp::ClockEvent *event)
 
             // And forward to the first router which is at the same position as the network
             // interface
-            _this->trace.msg(vp::Trace::LEVEL_DEBUG, "Injecting request to noc (req: %p, base: 0x%x, size: 0x%x, destination: (%d, %d))\n",
-                req, base, size, entry->x, entry->y);
+            _this->trace.msg(vp::Trace::LEVEL_DEBUG, "Injecting request to noc (req: %p, base: 0x%x, size: 0x%x, op_code: %0d, destination: (%d, %d))\n",
+                req, base, size, req->get_opcode(), entry->x, entry->y);
 
             // Noe that the router may not grant tje request if its input queue is full.
             // In this case we must stall the network interface
diff --git a/pulp/floonoc/floonoc_router.cpp b/pulp/floonoc/floonoc_router.cpp
index 50cb4ac..bc110bf 100644
--- a/pulp/floonoc/floonoc_router.cpp
+++ b/pulp/floonoc/floonoc_router.cpp
@@ -87,7 +87,8 @@ void Router::fsm_handler(vp::Block *__this, vp::ClockEvent *event)
     for (int i=0; i<5; i++)
     {
         vp::Queue *queue = _this->input_queues[queue_index];
-        if (!queue->empty())
+        // if (!queue->empty())
+        if (queue->size())
         {
             vp::IoReq *req = (vp::IoReq *)queue->head();
 
@@ -173,7 +174,7 @@ void Router::fsm_handler(vp::Block *__this, vp::ClockEvent *event)
             // Since we removed a request, check in next cycle if there is another one to handle
             _this->fsm_event.enqueue();
 
-            break;
+            // break;
         }
 
         // If we didn't any ready request, try with next queue
@@ -204,7 +205,7 @@ void Router::send_to_target(vp::IoReq *req, int pos_x, int pos_y)
         req->status = result;
         this->noc->handle_request_end(req);
     }
-    else if (vp::IO_REQ_DENIED)
+    else if (result == vp::IO_REQ_DENIED)
     {
         int queue = this->get_req_queue(pos_x, pos_y);
 
diff --git a/pulp/idma/fe/idma_fe_xdma.cpp b/pulp/idma/fe/idma_fe_xdma.cpp
index 867c0e2..7beaec0 100644
--- a/pulp/idma/fe/idma_fe_xdma.cpp
+++ b/pulp/idma/fe/idma_fe_xdma.cpp
@@ -46,6 +46,11 @@ IDmaFeXdma::IDmaFeXdma(vp::Component *idma, IdmaTransferConsumer *me)
 
     // Declare offload master interface for granting blocked transfers
     idma->new_master_port("offload_grant", &this->offload_grant_itf, this);
+
+    // track transfer time
+    this->transfer_start_time = 0;
+    this->num_inflight_transfer = 0;
+    this->total_idma_used_time = 0;
 }
 
 
@@ -133,6 +138,11 @@ uint32_t IDmaFeXdma::enqueue_copy(uint32_t config, uint32_t size, bool &granted)
     this->next_transfer_id.set(transfer_id + 1);
 
     this->trace.msg(vp::Trace::LEVEL_TRACE, "Allocated transfer ID (id: %d)\n", transfer_id);
+    if (this->num_inflight_transfer == 0)
+    {
+        this->transfer_start_time = this->time.get_time();
+    }
+    this->num_inflight_transfer += 1;
 
     // Allocate a new transfer and fill it from registers
     IdmaTransfer *transfer = new IdmaTransfer();
@@ -170,6 +180,12 @@ uint32_t IDmaFeXdma::enqueue_copy(uint32_t config, uint32_t size, bool &granted)
 void IDmaFeXdma::ack_transfer(IdmaTransfer *transfer)
 {
     this->completed_id.inc(1);
+    this->num_inflight_transfer -= 1;
+    if (this->num_inflight_transfer == 0)
+    {
+        this->total_idma_used_time += (this->time.get_time() - this->transfer_start_time)/1000;
+        this->trace.msg("[iDMA] Finished : %0d ns ---> %0d ns | period = %0d ns | runtime = %0d ns\n", (this->transfer_start_time/1000), (this->time.get_time()/1000), (this->time.get_time() - this->transfer_start_time)/1000, this->total_idma_used_time);
+    }
     delete transfer;
 }
 
diff --git a/pulp/idma/fe/idma_fe_xdma.hpp b/pulp/idma/fe/idma_fe_xdma.hpp
index 300ef51..05cc215 100644
--- a/pulp/idma/fe/idma_fe_xdma.hpp
+++ b/pulp/idma/fe/idma_fe_xdma.hpp
@@ -82,4 +82,9 @@ private:
     vp::Signal<bool> do_transfer_grant;
     // In case a transfer was blocked, gives the transfer which was blocked
     IdmaTransfer *stalled_transfer;
+
+    //track iDMA transfer time
+    int64_t transfer_start_time;
+    int64_t num_inflight_transfer;
+    int64_t total_idma_used_time;
 };
diff --git a/pulp/snitch/sequencer.cpp b/pulp/snitch/sequencer.cpp
index 673529f..080f26f 100644
--- a/pulp/snitch/sequencer.cpp
+++ b/pulp/snitch/sequencer.cpp
@@ -21,7 +21,7 @@
  */
 
 // Temporary workaround to let this component include ISS headers
-#include <../../../../isa_snitch_rv32imfdvca.hpp>
+#include <../../../../isa_snitch_rv32imfdva.hpp>
 
 #include <vp/vp.hpp>
 #include <vp/itf/io.hpp>
diff --git a/pulp/snitch/snitch_core.py b/pulp/snitch/snitch_core.py
index 0bda5e4..b00ea87 100644
--- a/pulp/snitch/snitch_core.py
+++ b/pulp/snitch/snitch_core.py
@@ -86,7 +86,7 @@ class Snitch(cpu.iss.riscv.RiscvCommon):
     def __init__(self,
             parent,
             name,
-            isa: str='rv32imafdc',
+            isa: str='rv32imafd',
             misa: int=None,
             binaries: list=[],
             fetch_enable: bool=False,
@@ -99,7 +99,7 @@ class Snitch(cpu.iss.riscv.RiscvCommon):
 
         if isa_instances.get(isa) is None:
             isa_instance = cpu.iss.isa_gen.isa_riscv_gen.RiscvIsa("snitch_" + isa, isa,
-                extensions=[ Rv32ssr(), Rv32frep(), Xdma(), Xf16(), Xf16alt(), Xf8(), Xfvec(), Xfaux() ] )
+                extensions=[ Rv32ssr(), Rv32frep(), Xdma(), Xf16(), Xf16alt(), Xf8(), Xfvec(), Xfaux(), Rv32redmule() ] )
             add_latencies(isa_instance)
             isa_instances[isa] = isa_instance
 
@@ -150,13 +150,16 @@ class Snitch(cpu.iss.riscv.RiscvCommon):
     def o_BARRIER_REQ(self, itf: gvsoc.systree.SlaveItf):
         self.itf_bind('barrier_req', itf, signature='wire<bool>')
 
+    def o_REDMULE(self, itf: gvsoc.systree.SlaveItf):
+        self.itf_bind('redmule_itf', itf, signature='io')
+
 
 class SnitchBare(cpu.iss.riscv.RiscvCommon):
 
     def __init__(self,
             parent,
             name,
-            isa: str='rv32imafdc',
+            isa: str='rv32imafd',
             misa: int=None,
             binaries: list=[],
             fetch_enable: bool=False,
@@ -197,7 +200,7 @@ class Snitch_fp_ss(cpu.iss.riscv.RiscvCommon):
     def __init__(self,
             parent,
             name,
-            isa: str='rv32imafdc',
+            isa: str='rv32imafd',
             misa: int=None,
             binaries: list=[],
             fetch_enable: bool=False,
@@ -209,7 +212,7 @@ class Snitch_fp_ss(cpu.iss.riscv.RiscvCommon):
 
 
         isa_instance = cpu.iss.isa_gen.isa_riscv_gen.RiscvIsa("snitch_fp_ss_" + isa, isa,
-            extensions=[ Rv32ssr(), Rv32frep(), Xdma(), Xf16(), Xf16alt(), Xf8(), Xfvec(), Xfaux() ] )
+            extensions=[ Rv32ssr(), Rv32frep(), Xdma(), Xf16(), Xf16alt(), Xf8(), Xfvec(), Xfaux(), Rv32redmule() ] )
 
         add_latencies(isa_instance)
 
@@ -266,7 +269,7 @@ class Spatz(cpu.iss.riscv.RiscvCommon):
     def __init__(self,
             parent,
             name,
-            isa: str='rv32imafdc',
+            isa: str='rv32imafd',
             misa: int=None,
             binaries: list=[],
             fetch_enable: bool=False,
diff --git a/pulp/snitch/snitch_isa.py b/pulp/snitch/snitch_isa.py
index 0f1fea3..3f5a975 100644
--- a/pulp/snitch/snitch_isa.py
+++ b/pulp/snitch/snitch_isa.py
@@ -100,3 +100,19 @@ class Rv32ssr(IsaSubset):
             Instr('scfgr', Format_SCFGR, '0000000----- 00001 001 ---- -0101011', tags=["ssr", 'nseq', 'fp_op']),
             Instr('scfgw', Format_SCFGW, '0000000----- ----- 010 0000 00101011', tags=["ssr", 'nseq', 'fp_op']),
         ])
+
+Format_MARITH = [
+    InReg (0, Range(15, 5)),
+    InReg (1, Range(20, 5)),
+    InReg (2, Range(27, 5)),
+    UnsignedImm(0, Range(7, 8)),
+]
+
+
+class Rv32redmule(IsaSubset):
+
+    def __init__(self):
+        super().__init__(name='redmule', instrs=[
+            Instr('mcnfig', Format_R     ,'0000000 ----- ----- 000 00000 0001010'),
+            Instr('marith', Format_MARITH,'-----00 ----- ----- --- ----- 0101010'),
+        ])
