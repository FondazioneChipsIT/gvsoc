diff --git a/pulp/floonoc/floonoc_router.cpp b/pulp/floonoc/floonoc_router.cpp
index 50cb4ac..bc110bf 100644
--- a/pulp/floonoc/floonoc_router.cpp
+++ b/pulp/floonoc/floonoc_router.cpp
@@ -87,7 +87,8 @@ void Router::fsm_handler(vp::Block *__this, vp::ClockEvent *event)
     for (int i=0; i<5; i++)
     {
         vp::Queue *queue = _this->input_queues[queue_index];
-        if (!queue->empty())
+        // if (!queue->empty())
+        if (queue->size())
         {
             vp::IoReq *req = (vp::IoReq *)queue->head();
 
@@ -173,7 +174,7 @@ void Router::fsm_handler(vp::Block *__this, vp::ClockEvent *event)
             // Since we removed a request, check in next cycle if there is another one to handle
             _this->fsm_event.enqueue();
 
-            break;
+            // break;
         }
 
         // If we didn't any ready request, try with next queue
@@ -204,7 +205,7 @@ void Router::send_to_target(vp::IoReq *req, int pos_x, int pos_y)
         req->status = result;
         this->noc->handle_request_end(req);
     }
-    else if (vp::IO_REQ_DENIED)
+    else if (result == vp::IO_REQ_DENIED)
     {
         int queue = this->get_req_queue(pos_x, pos_y);
 
diff --git a/pulp/idma/fe/idma_fe_xdma.cpp b/pulp/idma/fe/idma_fe_xdma.cpp
index 867c0e2..7beaec0 100644
--- a/pulp/idma/fe/idma_fe_xdma.cpp
+++ b/pulp/idma/fe/idma_fe_xdma.cpp
@@ -46,6 +46,11 @@ IDmaFeXdma::IDmaFeXdma(vp::Component *idma, IdmaTransferConsumer *me)
 
     // Declare offload master interface for granting blocked transfers
     idma->new_master_port("offload_grant", &this->offload_grant_itf, this);
+
+    // track transfer time
+    this->transfer_start_time = 0;
+    this->num_inflight_transfer = 0;
+    this->total_idma_used_time = 0;
 }
 
 
@@ -133,6 +138,11 @@ uint32_t IDmaFeXdma::enqueue_copy(uint32_t config, uint32_t size, bool &granted)
     this->next_transfer_id.set(transfer_id + 1);
 
     this->trace.msg(vp::Trace::LEVEL_TRACE, "Allocated transfer ID (id: %d)\n", transfer_id);
+    if (this->num_inflight_transfer == 0)
+    {
+        this->transfer_start_time = this->time.get_time();
+    }
+    this->num_inflight_transfer += 1;
 
     // Allocate a new transfer and fill it from registers
     IdmaTransfer *transfer = new IdmaTransfer();
@@ -170,6 +180,12 @@ uint32_t IDmaFeXdma::enqueue_copy(uint32_t config, uint32_t size, bool &granted)
 void IDmaFeXdma::ack_transfer(IdmaTransfer *transfer)
 {
     this->completed_id.inc(1);
+    this->num_inflight_transfer -= 1;
+    if (this->num_inflight_transfer == 0)
+    {
+        this->total_idma_used_time += (this->time.get_time() - this->transfer_start_time)/1000;
+        this->trace.msg("[iDMA] Finished : %0d ns ---> %0d ns | period = %0d ns | runtime = %0d ns\n", (this->transfer_start_time/1000), (this->time.get_time()/1000), (this->time.get_time() - this->transfer_start_time)/1000, this->total_idma_used_time);
+    }
     delete transfer;
 }
 
diff --git a/pulp/idma/fe/idma_fe_xdma.hpp b/pulp/idma/fe/idma_fe_xdma.hpp
index 300ef51..05cc215 100644
--- a/pulp/idma/fe/idma_fe_xdma.hpp
+++ b/pulp/idma/fe/idma_fe_xdma.hpp
@@ -82,4 +82,9 @@ private:
     vp::Signal<bool> do_transfer_grant;
     // In case a transfer was blocked, gives the transfer which was blocked
     IdmaTransfer *stalled_transfer;
+
+    //track iDMA transfer time
+    int64_t transfer_start_time;
+    int64_t num_inflight_transfer;
+    int64_t total_idma_used_time;
 };
